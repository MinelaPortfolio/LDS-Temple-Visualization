Index: app/src/main/java/edu/byuh/cis/templevis/TempleView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package edu.byuh.cis.templevis;\n\nimport android.annotation.SuppressLint;\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.res.Configuration;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Matrix;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.text.method.ScrollingMovementMethod;\nimport android.util.Log;\nimport android.view.Gravity;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.WindowManager;\nimport android.widget.Button;\nimport android.widget.LinearLayout;\nimport android.widget.ScrollView;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport androidx.annotation.RequiresApi;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Locale;\n\nimport static java.lang.Boolean.FALSE;\nimport static java.lang.Boolean.TRUE;\n\n\npublic class TempleView extends View {\n\n    public int howManyTemples = 232;\n    private int sliderMax;\n    private Paint bluePaint, redPaint, spiralPaint, yearDisplayPaint;\n    private float screenWidth, screenHeight;\n    public float theta;\n    private Path spiralLine;\n    private Boolean loadedImages;\n    private  float centerX;\n    private float centerY;\n    private float initialR;\n    private boolean sliderMoving;\n    public ArrayList<Temple> templeObjects; // more OO be more object oriented\n    private ArrayList<ArrayList<Float>> onScreenTemples;\n    private ArrayList<Float> oneOnScreenTemple;\n    private ArrayList<ArrayList<Float>> spiralCoordinates;\n    private ArrayList<Float> sizes;\n    private ArrayList<String> allTempleLinks;\n    private ArrayList<String> allTempleInfo;\n    public ArrayList<String> allYears;\n    public ArrayList<String> allTempleNames;\n    private int eachIndex;\n    private Matrix currentTempleMatrix;\n    private float topCoordinateInSpiralX;\n    private float topCoordinateInSpiralY;\n    private float largestSizeInSpiral;\n    private boolean coordinatesAndSizesUpdated;\n    private boolean orientationJustChanged;\n    public boolean touchDownOnScreenTempleView;\n    private float downX;\n    private float downY;\n    private ArrayList<Float> movingCoordinatesLastTime;\n    private long downTime;\n    private float ultimateScreenWidth;\n    private float initialRForLocation;\n    private float windowWidth;\n    private float windowHeight;\n    private String lastSpiralEffectHolder;\n    private static ArrayList<Integer> allLargeImageIds;\n    private String oneTempleInfo;\n    private static ArrayList<Integer> allTempleInfoFileIds;\n    private Boolean show_label;\n    private String selectedYear;\n    private Integer realEachIndex;\n    private String templeUrl;\n    private SingleTempleImage singleTempleImageView;\n    private int staticCoordinatesGet = 0;\n    private AlertDialog singleTempleDialog;\n    private int selectedTempleIndex = -1;\n    public String spiral_effect;\n\n\n    public TempleView(Context context) {\n        super(context);\n\n        bluePaint = new Paint();\n        bluePaint.setColor(Color.parseColor(\"#17252a\"));\n        bluePaint.setStyle(Paint.Style.FILL);\n        bluePaint.setTextSize(35);\n        redPaint = new Paint();\n        redPaint.setColor(Color.RED);\n        redPaint.setStyle(Paint.Style.FILL);\n        redPaint.setTextSize(60);\n        spiralPaint = new Paint();\n        spiralPaint.setColor(Color.RED);\n        spiralPaint.setStyle(Paint.Style.STROKE);\n        spiralPaint.setStrokeWidth(5);\n        spiralLine = new Path();\n        loadedImages = false;\n        spiralCoordinates = new ArrayList<>();\n        sizes = new ArrayList<>();\n        onScreenTemples = new ArrayList<>();\n        oneOnScreenTemple = new ArrayList<>();\n        allTempleLinks = new ArrayList<>();\n        allTempleInfo = new ArrayList<>();\n        allYears = new ArrayList<>();\n        allTempleNames = new ArrayList<>();\n        theta = 5550;\n        currentTempleMatrix = new Matrix();\n        coordinatesAndSizesUpdated = FALSE;\n        orientationJustChanged = FALSE;\n        movingCoordinatesLastTime = new ArrayList<>();\n        yearDisplayPaint = new Paint();\n        selectedYear = \"\";\n        sliderMax = howManyTemples * 30;\n\n    }\n\n    public void setDegree(int sliderP) {\n        theta = sliderP;\n        //Log.d(\"theta is \", theta + \" ***************************************************************************************\");\n    }\n\n    public float getLastProgress() {\n        //Log.d(\"theta\", \" is \" + theta + \" \");\n        return theta;\n    }\n\n    public void setSelectedTempleIndex(int i) {\n        selectedTempleIndex = i;\n    }\n\n    public boolean sliderMovingOrAnimationInProgress() {\n        return sliderMoving;\n    }\n\n    public void sliderStart(boolean s) {\n        sliderMoving = s;\n    }\n\n    public void sliderStop(boolean s) {\n        sliderMoving = s;\n    }\n\n    public void sliderInProgress(boolean s) {\n        sliderMoving = s;\n    }\n\n    public void readLinksFile() {\n        try {\n            InputStream allTempleLinksFile =  getContext().getResources().openRawResource(R.raw.all_temple_links);\n            if (allTempleLinksFile != null)\n            {\n                InputStreamReader ir = new InputStreamReader(allTempleLinksFile);\n                BufferedReader br = new BufferedReader(ir);\n                String line;\n                //read each line\n                int atThisLine = 0;\n                while (( line = br.readLine()) != null) {\n                    allTempleLinks.add(line+\"\\n\");\n                    if (atThisLine < templeObjects.size()) {\n                        templeObjects.get(atThisLine).setLink(line+\"\\n\");\n                        atThisLine ++;\n                    }\n                }\n                allTempleLinksFile.close();\n            }\n        }\n        catch (java.io.FileNotFoundException e)\n        {\n            Log.d(\"TestFile\", \"The File doesn't not exist.\");\n        }\n        catch (IOException e)\n        {\n            Log.d(\"TestFile\", e.getMessage());\n        }\n        //Log.d(\"allTempleLinks is \", allTempleLinks.get(1) + \"\");\n    }\n\n    public void readOneInfoFile(int id) {\n        try {\n            InputStream allTempleInfoFile =  this.getResources().openRawResource(id);\n            if (allTempleInfoFile != null)\n            {\n                InputStreamReader ir = new InputStreamReader(allTempleInfoFile);\n                BufferedReader br = new BufferedReader(ir);\n                String line;\n                //read each line\n                while (( line = br.readLine()) != null) {\n                    oneTempleInfo = oneTempleInfo + line+\"\\n\";\n                }\n                allTempleInfoFile.close();\n            }\n        }\n        catch (java.io.FileNotFoundException e)\n        {\n            Log.d(\"TestFile\", \"The File doesn't not exist.\");\n        }\n        catch (IOException e)\n        {\n            Log.d(\"TestFile\", e.getMessage());\n        }\n    }\n\n    public void readInfoFile() {\n        try {\n            InputStream allTempleInfoFile =  this.getResources().openRawResource(R.raw.temple_info);\n            if (allTempleInfoFile != null)\n            {\n                InputStreamReader ir = new InputStreamReader(allTempleInfoFile);\n                BufferedReader br = new BufferedReader(ir);\n                String line;\n                //read each line\n                while (( line = br.readLine()) != null) {\n                    allTempleInfo.add(line+\"\\n\");\n                }\n                allTempleInfoFile.close();\n                allYears = getAllYearsFromAllTempleInfo(allTempleInfo);\n                allTempleNames = getAllTempleNamesFromAllTempleInfo(allTempleInfo);\n            }\n        }\n        catch (java.io.FileNotFoundException e)\n        {\n            Log.d(\"TestFile\", \"The File doesn't not exist.\");\n        }\n        catch (IOException e)\n        {\n            Log.d(\"TestFile\", e.getMessage());\n        }\n\n    }\n\n    public ArrayList<String> getAllYearsFromAllTempleInfo(ArrayList<String> allTempleInfoPassIn) {\n        ArrayList<String> temporary = new ArrayList<>();\n//        for (int i = 0; i < temples.size(); i++) {\n        for (int i = 0; i < templeObjects.size(); i++) { // more OO\n            String year = allTempleInfo.get(i * 3 + 2) ;\n//            Locale curLocale = getResources().getConfiguration().locale;\n//            if (curLocale.equals(Locale.SIMPLIFIED_CHINESE)) {\n//                // do nothing //中文\n//                year = year;\n//            } else {\n//                year = year.substring(year.length()-5);\n//                //英文\n//            }\n\n            String curLan = getResources().getConfiguration().locale.getLanguage();\n            if (curLan.equals(\"zh\")) {\n                // do nothing //中文\n                year = year;\n            } else {\n                year = year.substring(year.length()-5);\n                //英文\n            }\n\n\n\n\n            temporary.add(year.substring(0,4));\n        }\n        return temporary;\n    }\n\n    public ArrayList<String> getAllTempleNamesFromAllTempleInfo(ArrayList<String> allTempleInfoPassIn) {\n        ArrayList<String> temporary = new ArrayList<>();\n        for (int i = 0; i < templeObjects.size(); i++) { // more OO\n            String name = allTempleInfo.get(i * 3 + 0) ;\n            temporary.add(name);\n        }\n        return temporary;\n    }\n\n\n\n    @RequiresApi(api = Build.VERSION_CODES.O)\n    @Override\n    public boolean onTouchEvent(MotionEvent m) {\n        float touchX= m.getX();;\n        float touchY= m.getY();;\n        //Log.d(\"TOUCH EVENT\",  \" touch event happens on screen at ************* \" + touchX + \" \" + touchY );\n        if (m.getAction() == MotionEvent.ACTION_DOWN) {\n            downX = m.getX();\n            downY = m.getY();\n            //Toast.makeText(getContext(), \"touched DOWN at \" + downX + \" \" + downY, Toast.LENGTH_SHORT).show();\n            movingCoordinatesLastTime.clear();\n            movingCoordinatesLastTime.add(downX);\n            movingCoordinatesLastTime.add(downY);\n            //Log.d(\"DOWN\",  \" finger down on screen at |||||||||||||||\" + downX + \" \" + downY );\n            touchDownOnScreenTempleView = TRUE;\n            downTime = System.currentTimeMillis();\n        }\n\n        if (m.getAction() == MotionEvent.ACTION_MOVE) {\n            //Toast.makeText(getContext(), \"finger moving on screen\", Toast.LENGTH_SHORT).show();\n\n            float movingX = m.getX();\n            float movingY = m.getY();\n            //Log.d(\"MOVING\",  \" finger moving on screen at \" + movingX + \" \" + movingY );\n\n            float lastX = movingCoordinatesLastTime.get(0);\n            float lastY = movingCoordinatesLastTime.get(1);\n            float xDisplacementFromLastMove = movingX - lastX;\n            float yDisplacementFromLastMove = movingY - lastY;\n            //Log.d(\"movingCoordinates\", \"movingCoordinatesLastTime is \" + movingCoordinatesLastTime);\n\n            movingCoordinatesLastTime.clear();\n            movingCoordinatesLastTime.add(movingX);\n            movingCoordinatesLastTime.add(movingY);\n            //Log.d(\"xy displacementFLT \", xDisplacementFromLastMove + \" \" + yDisplacementFromLastMove);\n\n            boolean top = (touchY <= centerY);\n            boolean bottom = (touchY < 9 * screenHeight / 10 && touchY > centerY);\n\n            boolean leftThirdVertical = (touchX <= centerX - screenWidth / 6 );\n            boolean middleThirdVertical = (touchX > centerX - screenWidth / 6 && touchX < centerX + screenWidth / 6);\n            boolean rightThirdVertical = (touchX >= centerX + screenWidth / 6 );\n\n            int moveTheta = 10;\n\n            boolean thetaMaxReached = theta >= sliderMax;\n            boolean thetaMinReached = theta <= 30;\n\n            if (leftThirdVertical) {\n                if (yDisplacementFromLastMove > 0) {\n                    if (thetaMaxReached) {\n                    } else {\n                        theta = theta + moveTheta;\n                    }\n                } else if (yDisplacementFromLastMove < 0) {\n                    if (thetaMinReached) {\n                    } else {\n                        theta = theta - moveTheta;\n                    }\n                }\n            } else if (rightThirdVertical) {\n                if (yDisplacementFromLastMove > 0) {\n                    if (thetaMinReached) {\n                    } else {\n                        theta = theta - moveTheta;\n                    }\n                } else if (yDisplacementFromLastMove < 0) {\n                    if (thetaMaxReached) {\n                    } else {\n                        theta = theta + moveTheta;\n                    }\n                }\n            } else if (middleThirdVertical) {\n                if (touchY > centerY - screenWidth / 6 && touchY < centerY + screenWidth / 6) {\n                    //do nothing, touch movement in center of spiral is disabled\n                } else if (top) {\n                    //check xd\n                    if (xDisplacementFromLastMove > 0) {\n                        if (thetaMinReached) {\n                        } else {\n                            theta = theta - moveTheta;\n                        }\n                    } else if (xDisplacementFromLastMove < 0) {\n                        if (thetaMaxReached) {\n                        } else {\n                            theta = theta + moveTheta;\n                        }\n                    }\n                } else if (bottom) {\n                    //check xd\n                    if (xDisplacementFromLastMove > 0) {\n                        if (thetaMaxReached) {\n                        } else {\n                            theta = theta + moveTheta;\n                        }\n                    } else if (xDisplacementFromLastMove < 0) {\n                        if (thetaMinReached) {\n                        } else {\n                            theta = theta - moveTheta;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (m.getAction() == MotionEvent.ACTION_UP) {\n            long upTime = System.currentTimeMillis();\n            long period = upTime - downTime;\n            touchDownOnScreenTempleView = FALSE;\n            //helper--time test\n            //Long timeLong = System.currentTimeMillis();\n            //String time = String.valueOf(timeLong);\n            //Toast.makeText(getContext(), \"current time is \" + time, Toast.LENGTH_SHORT).show();\n            float x = m.getX();\n            float y = m.getY();\n            //Toast.makeText(getContext(), \"touched a circle when UP at \" + x + \" \" + y, Toast.LENGTH_SHORT).show();\n\n            if (y < 9 * screenHeight / 10 && period < 100) {\n                boolean singleTempleViewOpened = false;\n\n                Collections.reverse(onScreenTemples);\n                for (ArrayList<Float> eachOnScreenTemple : onScreenTemples) {\n                    //remember each Float in inner class is a object, when convert it to int you need to use some method.\n                    eachIndex = (int)(eachOnScreenTemple.get(0).floatValue());\n                    float eachXCoordinate = eachOnScreenTemple.get(1);\n                    float eachYCoordinate = eachOnScreenTemple.get(2);\n                    float eachSize = eachOnScreenTemple.get(3);\n                    float distanceToCurrentCoordinate = (float) (Math.sqrt(Math.pow(Math.abs(x - eachXCoordinate), 2) + Math.pow(Math.abs(y - eachYCoordinate), 2)));\n\n                    if (distanceToCurrentCoordinate < eachSize) {\n                        //Toast.makeText(getContext(), \"touched a circle at \" + x + \" \" + y + \" and eachIndex here is \" + eachIndex , Toast.LENGTH_SHORT).show();\n                        //Toast.makeText(getContext(), \"how many onScreenTemples last time? \" + onScreenTemples.size(), Toast.LENGTH_SHORT).show();\n                        //Log.d(\"singleTempleViewOpen? \", singleTempleViewOpened + \"\");\n                        if (singleTempleViewOpened == false) {\n                            if (eachIndex <= templeObjects.size()) {\n                                singleTempleViewOpened = true;\n                                //Log.d(\"eachIndex is \", eachIndex + \" when click on circle\");\n                                singleTempleDialog();\n                            } else {\n                                //no link\n                                AlertDialog.Builder builder = new AlertDialog.Builder(getContext());\n                                builder.setTitle(\"Nothing Here\");\n                                builder.setMessage(\"future temples to come!\");\n                                builder.setIcon(R.mipmap.ic_launcher_round);\n                                builder.setCancelable(true);\n                                final AlertDialog dialog = builder.create();\n                                dialog.show();\n                            }\n                        }\n                    }\n                }\n                Collections.reverse(onScreenTemples);\n            }\n        }\n        return true;\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.O)\n    @SuppressLint(\"ClickableViewAccessibility\")\n    public void singleTempleDialog() {\n\n\n        LinearLayout.LayoutParams nice = new LinearLayout.LayoutParams\n                (LinearLayout.LayoutParams.MATCH_PARENT,\n                        LinearLayout.LayoutParams.MATCH_PARENT, 1);\n        LinearLayout.LayoutParams niceFour = new LinearLayout.LayoutParams\n                (LinearLayout.LayoutParams.MATCH_PARENT,\n                        LinearLayout.LayoutParams.MATCH_PARENT, 4);\n\n        LinearLayout.LayoutParams wrapContent = new LinearLayout.LayoutParams\n                (LinearLayout.LayoutParams.WRAP_CONTENT,\n                        LinearLayout.LayoutParams.WRAP_CONTENT, 1);\n\n        LinearLayout lnl = new LinearLayout(getContext());\n        lnl.setOrientation(LinearLayout.VERTICAL);\n\n        LinearLayout lnlH = new LinearLayout(getContext());\n        lnlH.setOrientation(LinearLayout.HORIZONTAL);\n\n        if (eachIndex == 0) {\n            singleTempleImageView = new SingleTempleImage(getContext(), allLargeImageIds.get(eachIndex), allLargeImageIds.get(eachIndex), allLargeImageIds.get(eachIndex + 1));\n        } else if (eachIndex == templeObjects.size() - 1){\n            singleTempleImageView = new SingleTempleImage(getContext(), allLargeImageIds.get(eachIndex), allLargeImageIds.get(eachIndex - 1), allLargeImageIds.get(eachIndex));\n        } else {\n            singleTempleImageView = new SingleTempleImage(getContext(), allLargeImageIds.get(eachIndex), allLargeImageIds.get(eachIndex - 1), allLargeImageIds.get(eachIndex + 1));\n        }\n\n        singleTempleImageView.setPadding(0,0,0,0);\n        //singleTempleImageView.setBackgroundColor(Color.RED);\n\n        // milestone dates\n        oneTempleInfo = \"\";\n        readOneInfoFile(allTempleInfoFileIds.get(eachIndex));\n\n        final TextView singleTempleTextView = new TextView(getContext());\n        singleTempleTextView.setText(oneTempleInfo);\n        //singleTempleTextView.setBackgroundColor(Color.BLUE);\n        singleTempleTextView.setGravity(Gravity.CENTER);\n\n        ScrollView sv = new ScrollView(getContext());\n        //sv.setPadding(100,100,100,100);\n        sv.addView(singleTempleTextView);\n\n        // here is where we get templeUrl, to avoid the eachIndex change error\n        //final String templeUrl = allTempleLinks.get(eachIndex);\n        realEachIndex = eachIndex; // we do this because each index is changing for some reason later...\n        templeUrl = templeObjects.get(realEachIndex).link;\n\n        final TextView singleTempleDialogTitleView = new TextView(getContext());\n        singleTempleDialogTitleView.setText(allTempleInfo.get(realEachIndex*3));\n        singleTempleDialogTitleView.setTextSize(20);\n        singleTempleDialogTitleView.setPadding(0,20,0,0);\n        singleTempleDialogTitleView.setTextColor(Color.BLACK);\n        singleTempleDialogTitleView.setGravity(Gravity.CENTER);\n        //singleTempleDialogTitleView.setHeight((int)(Math.min(screenWidth, screenHeight) * 0.1));\n        //singleTempleDialogTitleView.setMaxLines(1);\n        //singleTempleDialogTitleView.setAutoSizeTextTypeWithDefaults(TextView.AUTO_SIZE_TEXT_TYPE_UNIFORM);\n        //singleTempleDialogTitleView.setPadding(1, 1, 1, 1);\n        singleTempleDialogTitleView.setHeight((int)(Math.min(screenWidth, screenHeight) * 0.15));\n        //singleTempleDialogTitleView.setMovementMethod(ScrollingMovementMethod.getInstance());\n\n        final long[] timeStamp = new long[1];\n        timeStamp[0] = 0;\n        // view last or next temple buttons\n        Button left = new Button(getContext());\n        left.setWidth((int)screenWidth / 10);\n        left.setText(\">\");\n        left.setTextSize(20);\n        left.setOnTouchListener(new OnTouchListener() {\n            @Override\n            public boolean onTouch(View view, MotionEvent motionEvent) {\n                if(motionEvent.getAction() == MotionEvent.ACTION_DOWN){\n                    // do nothing\n                    //Toast.makeText(getContext(), realEachIndex.toString(), Toast.LENGTH_SHORT).show();\n                }else if(motionEvent.getAction() == MotionEvent.ACTION_UP){\n                    if (realEachIndex < templeObjects.size() - 1) {\n                        if (System.currentTimeMillis() - timeStamp[0] > 1550) {\n                            realEachIndex = realEachIndex + 1;\n                            singleTempleImageView.moveImage(\"left\");\n                            //Log.d(\"realEachIndex is \", realEachIndex.toString());\n                            if (realEachIndex == templeObjects.size() - 1) {\n                                singleTempleImageView.updateThreeTemplesBitmapIds(allLargeImageIds.get(realEachIndex), allLargeImageIds.get(realEachIndex - 1), allLargeImageIds.get(realEachIndex));\n                            } else {\n                                singleTempleImageView.updateThreeTemplesBitmapIds(allLargeImageIds.get(realEachIndex), allLargeImageIds.get(realEachIndex - 1), allLargeImageIds.get(realEachIndex + 1));\n                            }\n                            templeUrl = templeObjects.get(realEachIndex).link;\n                            singleTempleDialogTitleView.setText(allTempleInfo.get(realEachIndex*3));\n                            oneTempleInfo = \"\";\n                            readOneInfoFile(allTempleInfoFileIds.get(realEachIndex));\n                            singleTempleTextView.setText(oneTempleInfo);\n                            timeStamp[0] = System.currentTimeMillis();\n                        }\n                    } else {\n                        Toast.makeText(getContext(), getResources().getString(R.string.dubai_temple_is_the_most_recent_temple), Toast.LENGTH_SHORT).show();\n                    }\n                }\n                return false;\n            }\n        });\n\n        Button right = new Button(getContext());\n        right.setWidth((int)screenWidth / 10);\n        right.setText(\"<\");\n        right.setTextSize(20);\n        right.setOnTouchListener(new OnTouchListener() {\n            @Override\n            public boolean onTouch(View view, MotionEvent motionEvent) {\n                if(motionEvent.getAction() == MotionEvent.ACTION_DOWN){\n                    // do nothing\n                }else if(motionEvent.getAction() == MotionEvent.ACTION_UP){\n                    // do something\n                    if (realEachIndex > 0) {\n                        if (System.currentTimeMillis() - timeStamp[0] > 1550) {\n                            realEachIndex = realEachIndex - 1;\n                            singleTempleImageView.moveImage(\"right\");\n                            int lastTempleId = 0;\n                            if (realEachIndex - 1 < 0) {\n                                lastTempleId = allLargeImageIds.get(realEachIndex);\n                            } else {\n                                lastTempleId = allLargeImageIds.get(realEachIndex - 1);\n                            }\n                            singleTempleImageView.updateThreeTemplesBitmapIds(allLargeImageIds.get(realEachIndex), lastTempleId, allLargeImageIds.get(realEachIndex + 1));\n                            templeUrl = templeObjects.get(realEachIndex).link;\n                            singleTempleDialogTitleView.setText(allTempleInfo.get(realEachIndex*3));\n                            oneTempleInfo = \"\";\n                            readOneInfoFile(allTempleInfoFileIds.get(realEachIndex));\n                            singleTempleTextView.setText(oneTempleInfo);\n                            timeStamp[0] = System.currentTimeMillis();\n                        }\n                    } else {\n                        Toast.makeText(getContext(), getResources().getString(R.string.kirtland_temple_is_the_oldest_temple), Toast.LENGTH_SHORT).show();\n                    }\n                }\n                return false;\n            }\n        });\n\n        // the left button is actually on the right and the right button is actually on the left.\n        lnlH.addView(right); // lnlH.addView(left);\n        lnlH.addView(singleTempleImageView);\n        lnlH.addView(left); // lnlH.addView(right);\n\n        lnl.addView(singleTempleDialogTitleView);\n\n        lnlH.setBackgroundColor(Color.parseColor(\"#ffffee\"));\n        sv.setBackgroundColor(Color.parseColor(\"#ffffee\"));\n\n        lnl.addView(lnlH);\n        //lnlH.setBackgroundColor(Color.GREEN);\n        //lnl.addView(sv);\n\n        singleTempleTextView.setBackgroundColor(Color.parseColor(\"#ffffee\"));\n        ((ViewGroup)singleTempleTextView.getParent()).removeView(singleTempleTextView);\n        lnl.addView(singleTempleTextView);\n        //singleTempleTextView.setBackgroundColor(Color.RED);\n        singleTempleTextView.setHeight((int)(Math.min(screenWidth, screenHeight) * 0.2));\n        singleTempleTextView.setMovementMethod(ScrollingMovementMethod.getInstance());\n\n        singleTempleImageView.setLayoutParams(nice);\n        left.setLayoutParams(niceFour);\n        right.setLayoutParams(niceFour);\n        lnlH.setLayoutParams(nice);\n        // singleTempleDialog\n        AlertDialog.Builder builder = new AlertDialog.Builder(getContext());\n        //builder.setTitle(allTempleInfo.get(realEachIndex*3));\n        builder.setView(lnl);\n        builder.setCancelable(true);\n        builder.setCancelable(true);\n        builder.setPositiveButton(getResources().getString(R.string.website_button), new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int id) {\n                //do nothing\n            }\n        });\n        builder.setNegativeButton(getResources().getString(R.string.return_button), new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int id) {\n                //set onclick method for this button below\n            }\n        });\n        singleTempleDialog = builder.create();\n        singleTempleDialog.show();\n\n        //singleTempleDialog.getWindow().setBackgroundDrawableResource(android.R.color.transparent);\n        WindowManager.LayoutParams params = singleTempleDialog.getWindow().getAttributes();\n        int h = 0;\n        int w = 0;\n        if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {\n            h = (int)(Math.min(windowHeight, windowWidth) * 1.2);\n            w = (int)Math.min(windowHeight, windowWidth);\n        } else {\n            h = (int)(Math.min(windowHeight, windowWidth) * 0.9);\n            w = (int)Math.min(windowHeight, windowWidth);\n        }\n        params.height = h;\n        params.width =  w;\n        singleTempleDialog.getWindow().setAttributes(params);\n        singleTempleDialog.show();\n\n        Button btnPositive = singleTempleDialog.getButton(AlertDialog.BUTTON_POSITIVE);\n        Button btnNegative = singleTempleDialog.getButton(AlertDialog.BUTTON_NEGATIVE);\n\n        LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) btnPositive.getLayoutParams();\n        layoutParams.weight = 10;\n        btnPositive.setLayoutParams(layoutParams);\n        btnNegative.setLayoutParams(layoutParams);\n\n        singleTempleDialog.getButton(AlertDialog.BUTTON_POSITIVE).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                //singleTempleDialog.dismiss();\n                //singleTempleDialog stays when click on website button\n\n                // for some reason, i don't why, but each index is changed in here,\n                // so we get templeUrl before this, according to the correct eachIndex\n                //String templeUrl = allTempleLinks.get(eachIndex);\n                //Log.d(\"eachIndex is \", eachIndex + \" when click on website button\");\n                //Log.d(\"templeUrl is \", templeUrl + \"\");\n\n                if (templeUrl.equals(\"\" + \"\\n\")) {\n                    AlertDialog.Builder builder = new AlertDialog.Builder(getContext());\n                    builder.setTitle(\"No Link Available\");\n                    builder.setMessage(\"Temple does not have a website yet\");\n                    builder.setIcon(R.mipmap.ic_launcher_round);\n                    //点击对话框以外的区域是否让对话框消失\n                    builder.setCancelable(true);\n                    final AlertDialog dialog = builder.create();\n                    dialog.show();\n\n                } else {\n                    Intent eachTemplePage= new Intent();\n                    eachTemplePage.setAction(\"android.intent.action.VIEW\");\n                    Uri eachTemplePage_url = Uri.parse(templeUrl);\n                    eachTemplePage.setData(eachTemplePage_url);\n                    getContext().startActivity(eachTemplePage);\n                }\n            }\n        });\n    }\n\n    public void orientationJustChanged(boolean b) {\n        orientationJustChanged = b;\n        //singleTempleImageView.updatePositionAndSizeOnceOrientationChanged();\n        if (singleTempleImageView != null) { // the rotate phone without clicking on a temple\n            singleTempleImageView.orientationJustChanged(b);\n            //singleTempleImageView.invalidate();\n\n            // reset single temple dialog size according to screen size once orientation change happens\n            WindowManager.LayoutParams params = singleTempleDialog.getWindow().getAttributes();\n            int h = 0;\n            int w = 0;\n            if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {\n                h = (int)(Math.min(windowHeight, windowWidth) * 1.2);\n                w = (int)Math.min(windowHeight, windowWidth);\n            } else {\n                h = (int)(Math.min(windowHeight, windowWidth) * 0.9);\n                w = (int)Math.min(windowHeight, windowWidth);\n            }\n            params.height = h;\n            params.width =  w;\n            singleTempleDialog.getWindow().setAttributes(params);\n        }\n    }\n\n    public void getWindowSize(float w, float h) {\n        windowWidth = w;\n        windowHeight = h;\n    }\n\n    public void resetStaticCoordinatesGet() {\n        staticCoordinatesGet = 0;\n    }\n\n    @Override\n    public void onDraw(Canvas c) {\n\n//        if(templeObjects != null) {\n//            Log.d(\"temples number\", templeObjects.size() + \"\");\n//        }\n\n        //Toast.makeText(getContext(), \"onscreen temples\" + onScreenTemples.size(), Toast.LENGTH_SHORT).show();\n        //Log.d(\"onscreen temples \", \"\" + onScreenTemples.size());\n        if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {\n            screenWidth = c.getWidth() / 2;\n            screenHeight = c.getHeight();\n            centerX = screenWidth / 2 + 3 * screenWidth / 16;\n            centerY = screenHeight / 2;\n            ultimateScreenWidth = Math.min(windowHeight, windowWidth);\n            yearDisplayPaint.setTextSize((int)(2 * screenHeight / 25));\n        } else if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {\n            screenWidth = c.getWidth();\n            screenHeight = c.getHeight();\n            centerX = screenWidth * 0.57f;\n            centerY = screenHeight / 2;\n            ultimateScreenWidth = screenWidth;\n            yearDisplayPaint.setTextSize((int)(screenHeight / 25));\n            //Log.d(\"PORTRAIT \", \"|||||||||||||||||||||||||||||\" + screenWidth);\n        }\n        //Log.d(\"CENTER X \", centerX + \" \");\n        //Log.d(\"CENTER Y \", centerY + \" \");\n        initialR = screenWidth / 10;\n        initialRForLocation = ultimateScreenWidth / 10;\n\n        spiral_effect = PrefsActivity.getSpiralEffectPref(getContext());\n        show_label = PrefsActivity.getShowLabelPref(getContext());\n        //Log.d(\"spiral effect \", spiral_effect + \" \");\n\n        if (spiral_effect.equalsIgnoreCase(\"static\") && staticCoordinatesGet <= 10) {\n            spiralCoordinates.clear();\n            getCoordinates();\n            staticCoordinatesGet += 1;\n        }\n\n\n        if (orientationJustChanged == TRUE) {\n            spiralCoordinates.clear();\n            //sizes.clear();\n            getCoordinates();\n            //getSizes();\n            orientationJustChanged = FALSE;\n            //Log.d(\"coordinates and sizes \", \" just reset \");\n            //Log.d(\"orChanged coorSize \", \" ++++++++++++++++ \"\n                    //+ spiralCoordinates.size() + \" \"\n                    //+ sizes.size());\n            //Log.d(\"spiralCoordinates\", spiralCoordinates + \" \");\n            //Log.d(\"sizes\", sizes + \" \");\n        }\n        //when app first launch this got called.\n        if (coordinatesAndSizesUpdated == FALSE) {\n            spiralCoordinates.clear();\n            getCoordinates();\n            getSizes();\n            coordinatesAndSizesUpdated = TRUE;\n            //Log.d(\"launch coorSize \", \" ++++++++++++++++ \"\n                    //+ spiralCoordinates.size() + \" \"\n                    //+ sizes.size());\n            //Log.d(\"spiralCoordinates\", spiralCoordinates + \" \");\n            //Log.d(\"sizes\", sizes + \" \");\n            //Log.d(\"screenWidth\", screenWidth + \" \");\n            //Log.d(\"screenHeight\", screenHeight + \" \");\n        }\n\n\n        // we need to update the coordinates when switching to static mode from other effect. other wise coordinates for other effect will be kept.\n        if (spiral_effect.equalsIgnoreCase(\"static\")) {\n            //just turn to static or it was static before?\n            if (lastSpiralEffectHolder == null) {\n                //first time run, do noting\n            } else {\n                if (lastSpiralEffectHolder.equalsIgnoreCase(spiral_effect)) {\n                    //do nothing, it have been static last time\n                } else {\n                    //just turn to static, get a new coordinates\n                    spiralCoordinates.clear();\n                    getCoordinates();\n                }\n            }\n        } else {\n            //not static, do nothing\n        }\n        lastSpiralEffectHolder = spiral_effect;\n\n\n        if (spiral_effect.equalsIgnoreCase(\"spin\")) {\n            spiralCoordinates.clear();\n            getCoordinatesRotateRegular();\n        } else if (spiral_effect.equalsIgnoreCase(\"zoom\")) {\n            spiralCoordinates.clear();\n            getCoordinatesRotateZoom();\n        } else if (spiral_effect.equalsIgnoreCase(\"threeD\")) {\n            spiralCoordinates.clear();\n            getCoordinatesThreeD();\n        }\n\n        //c.drawColor(Color.parseColor(\"#66ccff\"));\n\n        //Temple View Background color\n        //c.drawColor(Color.parseColor(\"#24292b\"));\n        c.drawColor(Color.parseColor(\"#17252a\"));\n\n        //we just want to load the images once, we don't have to load it every time when we re-draw. otherwise the program is gonna be so slow\n        if (loadedImages == false) {\n            loadedImages = true;\n            //get the temple images in array list\n\n            //when app launches, images are loaded according to screen width\n            //when launches landscape, according to window height\n            float temp;\n            if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {\n                temp = windowHeight;\n            } else {\n                temp = screenWidth;\n            }\n\n            ResourceCache resourceCache = new ResourceCache(getContext(), temp);\n\n\n            ImageCache.init(getResources(), temp, screenHeight);\n            allLargeImageIds = ImageCache.getAllImageIds();\n            allTempleInfoFileIds = ImageCache.getAllTempleInfoFileIds();\n            //temples = ImageCache.getTemplesList();\n\n            // replacing this line\n//            templeObjects = ImageCache.getTempleObjectsList(); // more OO\n            // with\n            templeObjects = resourceCache.templeObjects;\n\n//            Log.d(\"old templeObjects size\", templeObjects.size() + \"\");\n\n            readLinksFile();\n            readInfoFile();\n\n\n//            for (Temple t: templeObjects) {\n//                t.setLink(allTempleLinks.get(templeObjects.indexOf(t)));\n//            }\n\n            yearDisplayPaint.setColor(Color.parseColor(\"#def2f1\"));\n            yearDisplayPaint.setStyle(Paint.Style.FILL);\n            yearDisplayPaint.setTextAlign(Paint.Align.CENTER);\n        }\n\n        //helper\n        //c.drawText(\"Screen Width and Height are \" + screenWidth + \" \" + screenHeight, 0, screenHeight - 100, bluePaint);\n        //c.drawText(\"how many temples \" + temples.size() + \" \", 0, screenHeight - 200, redPaint);\n        //c.drawRect(0,3 * screenHeight/4, screenWidth, 3 * screenHeight/4 + 10, bluePaint);\n        //the middle circle image is here ==============================================\n        //drawMiddleCircle(c);\n\n        placeAllCircles(c);\n\n        if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {\n            yearDisplayLandscape(c);\n\n        } else if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {\n            yearDisplay(c);\n        }\n\n\n    }\n\n    public void drawTempleLabels(float ts, Temple t, Canvas c) { // more OO\n\n        float newCurrentTempleRadius = t.size * screenWidth / 2;\n\n        Paint thisTempleLabelPaint = new Paint();\n\n        thisTempleLabelPaint.setColor(Color.parseColor(\"#def2f1\"));\n        thisTempleLabelPaint.setStyle(Paint.Style.FILL);\n        thisTempleLabelPaint.setTextSize((int)(newCurrentTempleRadius / 5));\n        thisTempleLabelPaint.setTextAlign(Paint.Align.CENTER);\n        thisTempleLabelPaint.setShadowLayer(20,0,-5,Color.BLACK);\n\n//        int thisTempleIndex = temples.indexOf(t);\n        int thisTempleIndex = templeObjects.indexOf(t); // more OO\n\n        String thisTempleName = allTempleInfo.get(thisTempleIndex*3);\n        Locale curLocale = getResources().getConfiguration().locale;\n        String curLan = getResources().getConfiguration().locale.getLanguage();\n        //Log.d(\"current language: \", curLan);\n\n        String thisTempleLocation = \"\";\n        //通过Locale的equals方法，判断出当前语言环境\n        //Log.d(\"thisTempleName: \", thisTempleName);\n//        if (curLocale.equals(Locale.SIMPLIFIED_CHINESE)) {\n//            //中文\n//            thisTempleLocation = thisTempleName.substring(0, thisTempleName.length() - 3);\n//            //Log.d(\"language: \", \"zh\");\n//        } else {\n//            //英文\n//            //Log.d(\"language: \", \"en\");\n//            thisTempleLocation = thisTempleName.substring(0, thisTempleName.length() - 7);\n//        }\n\n        if (curLan.equals(\"zh\")) {\n            //中文\n            thisTempleLocation = thisTempleName.substring(0, thisTempleName.length() - 3);\n        } else {\n            //英文\n            thisTempleLocation = thisTempleName.substring(0, thisTempleName.length() - 7);\n        }\n\n\n        //String thisTempleLocation = thisTempleName ;//.substring(0, thisTempleName.length() - 7);\n\n        String[] thisTempleLocationWords = thisTempleLocation.split(\" \");\n\n        String thisTempleNameOne = \"\";\n        String thisTempleNameTwo = \"\";\n        if (thisTempleLocationWords.length % 2 == 0) { // if there are even number of words in location, then each line has the same number of words\n            for (int i = 0; i < thisTempleLocationWords.length / 2; i ++) {\n                thisTempleNameOne += thisTempleLocationWords[i] + \" \";\n            }\n            for (int i = thisTempleLocationWords.length / 2; i < thisTempleLocationWords.length ; i ++) {\n                thisTempleNameTwo += thisTempleLocationWords[i] + \" \";\n            }\n        } else { // if there are odd number of words in location, then first line has one more line than second line\n            for (int i = 0; i < thisTempleLocationWords.length / 2 + 1; i ++) {\n                thisTempleNameOne += thisTempleLocationWords[i] + \" \";\n            }\n            for (int i = thisTempleLocationWords.length / 2 + 1; i < thisTempleLocationWords.length ; i ++) {\n                thisTempleNameTwo += thisTempleLocationWords[i] + \" \";\n            }\n        }\n\n        if (sliderMoving == false && ts < 200 && thisTempleIndex < 185 && show_label) {\n            //c.drawText(thisTempleName, currentTempleX, currentTempleY + newCurrentTempleRadius + thisTempleLabelPaint.getTextSize(), thisTempleLabelPaint);\n            c.drawText(thisTempleNameOne, t.x, t.y + newCurrentTempleRadius - thisTempleLabelPaint.getTextSize(), thisTempleLabelPaint);\n            c.drawText(thisTempleNameTwo, t.x, t.y + newCurrentTempleRadius, thisTempleLabelPaint);\n        }\n    }\n\n    public void getSelectedYear(String s) {\n        selectedYear = s;\n    }\n\n    public void actuallyDrawing(Temple t, Canvas c, int thisTempleIndex) { // more OO\n\n\n        float newCurrentTempleRadius = t.size * screenWidth / 2;\n\n        currentTempleMatrix.setScale(4 * t.size, 4 * t.size);\n//        currentTempleMatrix.postTranslate(currentTempleX - t.getWidth()  *currentTempleSize*2, currentTempleY - t.getHeight() * currentTempleSize*2);\n        currentTempleMatrix.postTranslate(t.x - t.image.getWidth()  * t.size * 2, t.y - t.image.getHeight() * t.size * 2); // more OO\n\n        Paint selectedYearTempleFramePaint = new Paint();\n        selectedYearTempleFramePaint.setColor(Color.parseColor(\"#287a78\"));\n        selectedYearTempleFramePaint.setStyle(Paint.Style.FILL);\n        if (selectedYear.equals(\"Temples under construction\") || selectedYear.equals(\"建设中的圣殿\")) {\n            selectedYear = \"0000\";\n        } else if (selectedYear.equals(\"Future Temples\") || selectedYear.equals(\"即将奉献的圣殿\")) {\n            selectedYear = \"1111\";\n        }\n        // if current temple is with selected year then draw a circle frame\n        if (allYears.get(thisTempleIndex).equals(selectedYear)) {\n            c.drawCircle(t.x, t.y, newCurrentTempleRadius * 1.1f , selectedYearTempleFramePaint);\n            if (!(selectedYear.equals(\"0000\") || selectedYear.equals(\"1111\"))) {\n                c.drawText(selectedYear, 100, 100, yearDisplayPaint);\n            }\n\n        } else {\n            // do nothing\n        }\n\n        if (selectedTempleIndex == thisTempleIndex) {\n            c.drawCircle(t.x, t.y, newCurrentTempleRadius * 1.1f , selectedYearTempleFramePaint);\n        }\n\n//        c.drawBitmap(t, currentTempleMatrix, null);\n        c.drawBitmap(t.image, currentTempleMatrix, null); // more OO\n    }\n\n    public void placeAllCircles(Canvas c) {\n        //place all circles, and get the index of on screen temples\n        //this method also call actualDrawing method to draw\n\n        //Log.d(\"spiralcoors: \", \" in placeallcircles \" + spiralCoordinates + \" \");\n        //Log.d(\"spiralcoors: \", \" in placeallcircles \" + spiralCoordinates + \" \");\n\n        onScreenTemples.clear();\n        for (Temple t : templeObjects) { //more OO: for (Bitmap t : temples) {\n            int thisTempleIndex = templeObjects.indexOf(t); // more OO: int thisTempleIndex = temples.indexOf(t);\n            float ts = theta - 30 * templeObjects.indexOf(t); // more OO: float ts = theta - 30 * temples.indexOf(t);\n            if (ts > 0 && ts < spiralCoordinates.size() - 1) {\n\n                // set this temple's size, x and y once we know it should be on screen\n                t.size = sizes.get((int) (ts));\n                t.x = spiralCoordinates.get((int) (ts)).get(0);\n                t.y = spiralCoordinates.get((int) (ts)).get(1);\n\n                actuallyDrawing(t, c, thisTempleIndex);\n                drawTempleLabels(ts, t, c);\n\n                //add all on screen temples index to a array list once the slider stopped moving,\n                float currentTempleRadius = t.size * screenWidth / 2;\n                //inner array list: (this onScreenTemple index, x coordinate, y coordinate, temple radius at this position)\n                oneOnScreenTemple.add((float)thisTempleIndex);\n                oneOnScreenTemple.add(t.x);\n                oneOnScreenTemple.add(t.y);\n                oneOnScreenTemple.add(currentTempleRadius);\n                //be aware of adding one array list to another array list of array list then clear old one, remember you must copy.\n                ArrayList<Float> oneOnScreenTempleCopy = new ArrayList<>();\n                oneOnScreenTempleCopy.addAll(oneOnScreenTemple);\n                onScreenTemples.add(oneOnScreenTempleCopy);\n                oneOnScreenTemple.clear();\n            }\n        }\n        // we need this line of code, so that in 3 d view, only the front temple opens when user clicks\n        Collections.reverse(onScreenTemples);\n        //Log.d(\"onscreen temples \", \"\" + onScreenTemples.size());\n    }\n\n    public void yearDisplay(Canvas c) {\n\n        //get the index of on screen temples,\n        //the first one in on screen temples to the last\n        //go to temple info file, the specific line to get years\n        //3 lines each temple in the file\n\n        //c.drawRect(0, 9 * screenHeight / 10, screenWidth, screenHeight, bluePaint);\n        float firstOnScreenTempleIndex = 0;\n        float lastOnScreenTempleIndex = 0;\n\n        // new year display logic\n        if (onScreenTemples.size() != 0) {\n            lastOnScreenTempleIndex = (onScreenTemples.get(onScreenTemples.size()-1).get(0));\n            firstOnScreenTempleIndex = (onScreenTemples.get(0).get(0));\n        }\n\n        String endYear = allTempleInfo.get((int)(firstOnScreenTempleIndex) * 3 + 2);\n        String startYear = allTempleInfo.get((int)(lastOnScreenTempleIndex) * 3 + 2) ;\n\n\n        String curLan = getResources().getConfiguration().locale.getLanguage();\n\n        Locale curLocale = getResources().getConfiguration().locale;\n//        if (curLocale.equals(Locale.SIMPLIFIED_CHINESE)) {\n//            // do nothing //中文\n//            startYear = startYear.substring(0,4);\n//            endYear = endYear.substring(0,4);\n//        } else {\n//            startYear = startYear.substring(startYear.length()-5);\n//            endYear = endYear.substring(endYear.length()-5);\n//            //英文\n//        }\n\n        if (curLan.equals(\"zh\")) {\n            // do nothing //中文\n            startYear = startYear.substring(0,4);\n            endYear = endYear.substring(0,4);\n        } else {\n            startYear = startYear.substring(startYear.length()-5);\n            endYear = endYear.substring(endYear.length()-5);\n            //英文\n        }\n\n\n\n        if (theta <= 40){\n            c.drawText( getResources().getString(R.string.first_temple) + \"\" + \"1836\", screenWidth / 2, 39 * screenHeight / 40, yearDisplayPaint);\n        } else if (theta > 5550 ) {\n            c.drawText( getResources().getString(R.string.future_temples), screenWidth / 2, 39 * screenHeight / 40, yearDisplayPaint);\n        } else if (endYear.contains(\"0000\") || endYear.contains(\"1111\")){\n            c.drawText( getResources().getString(R.string.years_of_temples) + \" \"  + startYear + \"--- \" + 2020, screenWidth / 2, 39 * screenHeight / 40, yearDisplayPaint);\n        } else {\n            //Log.d(\"endYeas is \", endYear);\n            c.drawText( getResources().getString(R.string.years_of_temples) + \" \"  + startYear + \"--- \" + endYear, screenWidth / 2, 39 * screenHeight / 40, yearDisplayPaint);\n        }\n    }\n\n    public void yearDisplayLandscape(Canvas c) {\n        c.drawRect( 5 * screenWidth / 4, 0, 2 * screenWidth, screenHeight, bluePaint);\n        float firstOnScreenTempleIndex = 0;\n        float lastOnScreenTempleIndex = 0;\n\n        // new year display logic\n        if (onScreenTemples.size() != 0) {\n            lastOnScreenTempleIndex = (onScreenTemples.get(onScreenTemples.size()-1).get(0));\n            firstOnScreenTempleIndex = (onScreenTemples.get(0).get(0));\n        }\n        String endYear = allTempleInfo.get((int)(firstOnScreenTempleIndex) * 3 + 2);\n        String startYear = allTempleInfo.get((int)(lastOnScreenTempleIndex) * 3 + 2) ;\n\n        String curLan = getResources().getConfiguration().locale.getLanguage();\n        if (curLan.equals(\"zh\")) {\n            // do nothing //中文\n            startYear = startYear.substring(0,4);\n            endYear = endYear.substring(0,4);\n        } else {\n            startYear = startYear.substring(startYear.length()-5);\n            endYear = endYear.substring(endYear.length()-5);\n            //英文\n        }\n\n\n//        Locale curLocale = getResources().getConfiguration().locale;\n//        if (curLocale.equals(Locale.SIMPLIFIED_CHINESE)) {\n//            // do nothing //中文\n//            startYear = startYear.substring(0,4);\n//            endYear = endYear.substring(0,4);\n//        } else {\n//            startYear = startYear.substring(startYear.length()-5);\n//            endYear = endYear.substring(endYear.length()-5);\n//            //英文\n//        }\n\n\n\n\n\n            //String curLan = getResources().getConfiguration().locale.getLanguage();\n            if (curLan.equals(\"zh\")) {\n                // do nothing //中文\n                startYear = startYear.substring(0,4);\n                endYear = endYear.substring(0,4);\n            } else {\n                startYear = startYear.substring(startYear.length()-5);\n                endYear = endYear.substring(endYear.length()-5);\n                //英文\n            }\n\n        if (theta <= 40){\n            c.drawText(getResources().getString(R.string.first_temple), 6.5f * screenWidth / 4, 18 * screenHeight / 40, yearDisplayPaint);\n            c.drawText(\"1836\", 6.5f * screenWidth / 4, 22 * screenHeight / 40, yearDisplayPaint);\n        } else if (theta > 5550 ) {\n            c.drawText(getResources().getString(R.string.future_temples), 6.5f * screenWidth / 4, 20 * screenHeight / 40, yearDisplayPaint);\n        } else if (endYear.contains(\"0000\") || endYear.contains(\"1111\")){\n            c.drawText(getResources().getString(R.string.years_of_temples) + \" \" , 6.5f * screenWidth / 4, 15 * screenHeight / 40, yearDisplayPaint);\n            c.drawText(startYear + \" --- \" + 2020, 6.5f * screenWidth / 4, 25 * screenHeight / 40, yearDisplayPaint);\n        } else {\n            c.drawText(getResources().getString(R.string.years_of_temples) + \" \" , 6.5f * screenWidth / 4, 15 * screenHeight / 40, yearDisplayPaint);\n            c.drawText(startYear + \" --- \" + endYear, 6.5f * screenWidth / 4, 25 * screenHeight / 40, yearDisplayPaint);\n       }\n    }\n\n    public void getCoordinates() {\n        //spiral are impacted a lot by initialR.\n        //circles locations remain whether landscape or portrait\n        if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {\n            //initialRForLocation is 0 when app launches, causing spiral becomes a dot.\n            //when first launch, I treat windowHeight as initial R, which is just screen width later\n            //(有差距，因为有状态栏，so window height is slightly smaller than screen width)\n            if (coordinatesAndSizesUpdated == FALSE) {\n                initialR = windowHeight / 10;\n            } else {\n                initialR = initialRForLocation;\n            }\n            //Log.d(\"initialR\", \" \" + initialR);\n        } else if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {\n            initialR = screenWidth / 10;\n        }\n\n        //for (float t = -30; t < 30; t += 0.02f) {\n        for (float t = -18; t < 17.5; t += 0.02f) {\n            //Equiangular spiral function：\n            //x = p * cosA, y = p * sinA, where p = N * e^(B * cotC)\n            //When C = PI/2, graph is a circle, when C = 0, graph is a straight line\n            float x = centerX + initialR * (float) (Math.exp(t * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.cos(t));\n            float y = centerY + initialR * (float) (Math.exp(t * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.sin(t));\n\n            //intendSize is the new size compare to original (original has width of 0.1 * screenWidth)\n\n            ArrayList<Float> oneSpiralCoordinate = new ArrayList<>();\n            oneSpiralCoordinate.add(x);\n            oneSpiralCoordinate.add(y);\n\n            ArrayList<Float> oneSpiralCoordinateCopy = new ArrayList<>();\n            oneSpiralCoordinateCopy.addAll(oneSpiralCoordinate);\n            //Log.d(\"x y coordinate\", oneSpiralCoordinate.get(0) + \"<- x, y -> \" + oneSpiralCoordinate.get(1));\n            spiralCoordinates.add(oneSpiralCoordinateCopy);\n            //Log.d(\"x y coordinate\", \"right after adding, spiralCoordinates are \" + spiralCoordinates);\n            oneSpiralCoordinate.clear();\n        }\n\n        topCoordinateInSpiralX = spiralCoordinates.get(spiralCoordinates.size()-1).get(0);\n        topCoordinateInSpiralY = spiralCoordinates.get(spiralCoordinates.size()-1).get(1);\n\n        //when q += 12f, top lines circles next to each other the whole time\\\n        //must change the same time as getCoordinates()\n        for (float q = 0; q < 20; q += 1) {\n\n            ArrayList<Float> oneSpiralCoordinateTop = new ArrayList<>();\n            oneSpiralCoordinateTop.add(topCoordinateInSpiralX + q * 20);\n            oneSpiralCoordinateTop.add(topCoordinateInSpiralY);\n\n            ArrayList<Float> oneSpiralCoordinateTopCopy = new ArrayList<>();\n            oneSpiralCoordinateTopCopy.addAll(oneSpiralCoordinateTop);\n            spiralCoordinates.add(oneSpiralCoordinateTopCopy);\n            oneSpiralCoordinateTop.clear();\n        }\n        //Toast.makeText(getContext(), spiralCoordinates.size() + \" \", Toast.LENGTH_SHORT).show();\n        Collections.reverse(spiralCoordinates);\n    }\n\n    public void getCoordinatesRotateRegular() {\n        //spiral are impacted a lot by initialR.\n        //circles locations remain whether landscape or portrait\n        if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {\n            //initialRForLocation is 0 when app launches, causing spiral becomes a dot.\n            //when first launch, I treat windowHeight as initial R, which is just screen width later\n            //(有差距，因为有状态栏，so window height is slightly smaller than screen width)\n            if (coordinatesAndSizesUpdated == FALSE) {\n                initialR = windowHeight / 10;\n            } else {\n                initialR = initialRForLocation;\n            }\n            //Log.d(\"initialR\", \" \" + initialR);\n        } else if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {\n            initialR = screenWidth / 10;\n        }\n        //for (float t = -30; t < 30; t += 0.02f) {\n        for (float t = -18; t < 17.5; t += 0.02f) {\n            //Equiangular spiral function：\n            //x = p * cosA, y = p * sinA, where p = N * e^(B * cotC)\n            //When C = PI/2, graph is a circle, when C = 0, graph is a straight line\n            float x = centerX + initialR * (float) (Math.exp(t * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.cos(t));\n            float y = centerY + initialR * (float) (Math.exp(t * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.sin(t));\n\n            //intendSize is the new size compare to original (original has width of 0.1 * screenWidth)\n\n            float angle = theta / 100;\n            float xNew = (x - centerX) * (float) (Math.cos(angle)) - (y - centerY) * (float) (Math.sin(angle)) + centerX;\n            float yNew = (y - centerY) * (float) (Math.cos(angle)) + (x - centerX) * (float) (Math.sin(angle)) + centerY;\n\n            ArrayList<Float> oneSpiralCoordinate = new ArrayList<>();\n            oneSpiralCoordinate.add(xNew);\n            oneSpiralCoordinate.add(yNew);\n\n            ArrayList<Float> oneSpiralCoordinateCopy = new ArrayList<>();\n            oneSpiralCoordinateCopy.addAll(oneSpiralCoordinate);\n            //Log.d(\"x y coordinate\", oneSpiralCoordinate.get(0) + \"<- x, y -> \" + oneSpiralCoordinate.get(1));\n            spiralCoordinates.add(oneSpiralCoordinateCopy);\n            //Log.d(\"x y coordinate\", \"right after adding, spiralCoordinates are \" + spiralCoordinates);\n            oneSpiralCoordinate.clear();\n        }\n\n        topCoordinateInSpiralX = spiralCoordinates.get(spiralCoordinates.size()-1).get(0);\n        topCoordinateInSpiralY = spiralCoordinates.get(spiralCoordinates.size()-1).get(1);\n\n        float secondTopCoordinateInSpiralX = spiralCoordinates.get(spiralCoordinates.size()-2).get(0);\n        float secondTopCoordinateInSpiralY = spiralCoordinates.get(spiralCoordinates.size()-2).get(1);\n\n        //when q += 12f, top lines circles next to each other the whole time\\\n        //must change the same time as getCoordinates()\n        for (float q = 0; q < 20; q += 1) {\n\n            ArrayList<Float> oneSpiralCoordinateTop = new ArrayList<>();\n\n            float xDirection = topCoordinateInSpiralX - secondTopCoordinateInSpiralX;\n            float yDirection = topCoordinateInSpiralY - secondTopCoordinateInSpiralY;\n\n            float step = q * 30;\n            oneSpiralCoordinateTop.add(xDirection / Math.abs(xDirection) * step + secondTopCoordinateInSpiralX);\n            oneSpiralCoordinateTop.add(yDirection / Math.abs(yDirection) * step + secondTopCoordinateInSpiralY);\n\n            ArrayList<Float> oneSpiralCoordinateTopCopy = new ArrayList<>();\n            oneSpiralCoordinateTopCopy.addAll(oneSpiralCoordinateTop);\n            spiralCoordinates.add(oneSpiralCoordinateTopCopy);\n            oneSpiralCoordinateTop.clear();\n        }\n        //Toast.makeText(getContext(), spiralCoordinates.size() + \" \", Toast.LENGTH_SHORT).show();\n        Collections.reverse(spiralCoordinates);\n    }\n\n    public void getCoordinatesRotateZoom() {\n        //spiral are impacted a lot by initialR.\n        //circles locations remain whether landscape or portrait\n        if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {\n            //initialRForLocation is 0 when app launches, causing spiral becomes a dot.\n            //when first launch, I treat windowHeight as initial R, which is just screen width later\n            //(有差距，因为有状态栏，so window height is slightly smaller than screen width)\n            if (coordinatesAndSizesUpdated == FALSE) {\n                initialR = windowHeight / 10;\n            } else {\n                initialR = initialRForLocation;\n            }\n            //Log.d(\"initialR\", \" \" + initialR);\n        } else if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {\n            initialR = screenWidth / 10;\n        }\n        //for (float t = -30; t < 30; t += 0.02f) {\n        for (float t = -18; t < 17.5; t += 0.02f) {\n            //Equiangular spiral function：\n            //x = p * cosA, y = p * sinA, where p = N * e^(B * cotC)\n            //When C = PI/2, graph is a circle, when C = 0, graph is a straight line\n            float x = centerX + initialR * (float) (Math.exp(t * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.cos(t));\n            float y = centerY + initialR * (float) (Math.exp(t * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.sin(t));\n\n            //intendSize is the new size compare to original (original has width of 0.1 * screenWidth)\n\n            float angle = theta / 50;\n            float xNew = (x - centerX) * (float) (Math.cos(angle)) - (y - centerY) * (float) (Math.sin(angle)) + centerX;\n            float yNew = (y - centerY) * (float) (Math.cos(angle)) + (x - centerX) * (float) (Math.sin(angle)) + centerY;\n\n            ArrayList<Float> oneSpiralCoordinate = new ArrayList<>();\n            oneSpiralCoordinate.add(xNew);\n            oneSpiralCoordinate.add(yNew);\n\n            ArrayList<Float> oneSpiralCoordinateCopy = new ArrayList<>();\n            oneSpiralCoordinateCopy.addAll(oneSpiralCoordinate);\n            //Log.d(\"x y coordinate\", oneSpiralCoordinate.get(0) + \"<- x, y -> \" + oneSpiralCoordinate.get(1));\n            spiralCoordinates.add(oneSpiralCoordinateCopy);\n            //Log.d(\"x y coordinate\", \"right after adding, spiralCoordinates are \" + spiralCoordinates);\n            oneSpiralCoordinate.clear();\n        }\n\n        topCoordinateInSpiralX = spiralCoordinates.get(spiralCoordinates.size()-1).get(0);\n        topCoordinateInSpiralY = spiralCoordinates.get(spiralCoordinates.size()-1).get(1);\n\n        //when q += 12f, top lines circles next to each other the whole time\\\n        //must change the same time as getCoordinates()\n        for (float q = 0; q < 20; q += 1) {\n\n            ArrayList<Float> oneSpiralCoordinateTop = new ArrayList<>();\n\n            float xDirection = topCoordinateInSpiralX - centerX;\n            float yDirection = topCoordinateInSpiralY - centerY;\n\n            float step = q * 10;\n            oneSpiralCoordinateTop.add((xDirection) / Math.abs(xDirection) * step + topCoordinateInSpiralX);\n            oneSpiralCoordinateTop.add((yDirection) / Math.abs(yDirection) * step + topCoordinateInSpiralY);\n\n            ArrayList<Float> oneSpiralCoordinateTopCopy = new ArrayList<>();\n            oneSpiralCoordinateTopCopy.addAll(oneSpiralCoordinateTop);\n            spiralCoordinates.add(oneSpiralCoordinateTopCopy);\n            oneSpiralCoordinateTop.clear();\n        }\n        //Toast.makeText(getContext(), spiralCoordinates.size() + \" \", Toast.LENGTH_SHORT).show();\n        Collections.reverse(spiralCoordinates);\n    }\n\n    public void getCoordinatesThreeD() {\n        //spiral are impacted a lot by initialR.\n        //circles locations remain whether landscape or portrait\n        if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {\n            //initialRForLocation is 0 when app launches, causing spiral becomes a dot.\n            //when first launch, I treat windowHeight as initial R, which is just screen width later\n            //(有差距，因为有状态栏，so window height is slightly smaller than screen width)\n            if (coordinatesAndSizesUpdated == FALSE) {\n                initialR = windowHeight / 10;\n            } else {\n                initialR = initialRForLocation;\n            }\n            //Log.d(\"initialR\", \" \" + initialR);\n        } else if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {\n            initialR = screenWidth / 10;\n        }\n        //for (float t = -30; t < 30; t += 0.02f) {\n        for (float t = -18; t < 17.5; t += 0.02f) {\n            //Equiangular spiral function：\n            //x = p * cosA, y = p * sinA, where p = N * e^(B * cotC)\n            //When C = PI/2, graph is a circle, when C = 0, graph is a straight line\n            float x = centerX + initialR * (float) (Math.exp(t * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.cos(t));\n            float y = centerY + initialR * (float) (Math.exp(t * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.sin(t));\n\n            //intendSize is the new size compare to original (original has width of 0.1 * screenWidth)\n\n            float angle = theta / 500;\n            x = (x - centerX) * (float) (Math.cos(angle)) - (y - centerY) * (float) (Math.sin(angle)) + centerX;\n            y = (y - centerY) * (float) (Math.cos(angle)) + (x - centerX) * (float) (Math.sin(angle)) + centerY;\n\n            ArrayList<Float> oneSpiralCoordinate = new ArrayList<>();\n            oneSpiralCoordinate.add(x);\n            oneSpiralCoordinate.add(y);\n\n            ArrayList<Float> oneSpiralCoordinateCopy = new ArrayList<>();\n            oneSpiralCoordinateCopy.addAll(oneSpiralCoordinate);\n            //Log.d(\"x y coordinate\", oneSpiralCoordinate.get(0) + \"<- x, y -> \" + oneSpiralCoordinate.get(1));\n            spiralCoordinates.add(oneSpiralCoordinateCopy);\n            //Log.d(\"x y coordinate\", \"right after adding, spiralCoordinates are \" + spiralCoordinates);\n            oneSpiralCoordinate.clear();\n        }\n\n        topCoordinateInSpiralX = spiralCoordinates.get(spiralCoordinates.size()-1).get(0);\n        topCoordinateInSpiralY = spiralCoordinates.get(spiralCoordinates.size()-1).get(1);\n\n        //when q += 12f, top lines circles next to each other the whole time\\\n        //must change the same time as getCoordinates()\n        for (float q = 0; q < 20; q += 1) {\n\n            ArrayList<Float> oneSpiralCoordinateTop = new ArrayList<>();\n            oneSpiralCoordinateTop.add(topCoordinateInSpiralX + q * 20);\n            oneSpiralCoordinateTop.add(topCoordinateInSpiralY);\n\n            ArrayList<Float> oneSpiralCoordinateTopCopy = new ArrayList<>();\n            oneSpiralCoordinateTopCopy.addAll(oneSpiralCoordinateTop);\n            spiralCoordinates.add(oneSpiralCoordinateTopCopy);\n            oneSpiralCoordinateTop.clear();\n        }\n        //Toast.makeText(getContext(), spiralCoordinates.size() + \" \", Toast.LENGTH_SHORT).show();\n        Collections.reverse(spiralCoordinates);\n    }\n\n    public void getSizes() {\n        float pi = (float) Math.PI;\n\n        //circles sizes remain whether landscape or portrait\n        initialR = screenWidth / 10;\n        //Toast.makeText(getContext(), \"getSizes called, sizes.length is \" + sizes.size(), Toast.LENGTH_SHORT).show();\n\n        float newSize = 0;\n        //for (float t = -30; t < 30; t += 0.02f) {\n        for (float t = -18; t < 17.5; t += 0.02f) {\n            float x = centerX + initialR * (float) (Math.exp(t * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.cos(t));\n            float y = centerY + initialR * (float) (Math.exp(t * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.sin(t));\n\n            float t2 = t - 2 * pi;\n            float x2 = centerX + initialR * (float) (Math.exp(t2 * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.cos(t2));\n            float y2 = centerY + initialR * (float) (Math.exp(t2 * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.sin(t2));\n            newSize = (float) (Math.sqrt(Math.pow(Math.abs(x - x2), 2) + Math.pow(Math.abs(y - y2), 2)));\n            newSize = (newSize / screenWidth * 1.3f);\n            sizes.add(newSize);\n        }\n        //Log.d(\"sizes 1400 are \", \" \" + sizes.get(1400));\n        //Log.d(\"sizes size is \", \" \" + sizes.size());\n        //Log.d(\"initialR is \", \" \" + initialR);\n\n        int sizesSizeInSpiralPart = sizes.size();\n        largestSizeInSpiral = sizes.get(sizesSizeInSpiralPart - 1);\n\n        //when q += 12f, top lines circles next to each other the whole time\n        //must change the same time as getCoordinates()\n        for (float q = 0; q < 20; q += 1) {\n            sizes.add(largestSizeInSpiral);\n//            if (sizes.size() >= spiralCoordinates.size()) {\n//                break;\n//            }\n        }\n        Collections.reverse(sizes);\n    }\n\n    public void drawSpiral(Canvas c) {\n        float e = (float) (Math.E);\n        float a = screenWidth / 10;\n        //draw spiral\n        spiralLine.reset();\n        spiralLine.moveTo(centerX, centerY);\n        //radius of the circle in the middle\n        //c.drawCircle(centerX, centerY, initialR, spiralPaint);\n        Log.d(\"theta \", \"is \" + theta);\n        for (float t = -18; t < 17.5; t += 0.02f) {\n            //Equiangular spiral function：\n            //x = p * cosA, y = p * sinA, where p = N * e^(B * cotC)\n            //When C = PI/2, graph is a circle, when C = 0, graph is a straight line\n//            float x = centerX + a * (float) (Math.exp(t * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.cos(t));\n//            float y = centerY + a * (float) (Math.exp(t * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.sin(t));\n            float x = centerX + a * (float) (Math.exp(t * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.cos(t));\n            float y = centerY + a * (float) (Math.exp(t * 1 / (Math.tan(47 * Math.PI / 100)))) * (float) (Math.sin(t));\n\n            // rotates about (0, 0)\n            //float xNew = x * (float)(Math.cos(theta)) + y * (float)(Math.sin(theta));\n            //float yNew = y * (float)(Math.cos(theta)) - x * (float)(Math.sin(theta));\n\n            float angle = theta / 500;\n            float xNew = (x - centerX) * (float) (Math.cos(angle)) - (y - centerY) * (float) (Math.sin(angle)) + centerX;\n            float yNew = (y - centerY) * (float) (Math.cos(angle)) + (x - centerX) * (float) (Math.sin(angle)) + centerY;\n\n            //spiral doesn't rotates\n            //spiralLine.lineTo(x, y);\n\n            //spiral rotates\n            spiralLine.lineTo(xNew, yNew);\n        }\n        //draw the spiral ****************************************\n        c.drawPath(spiralLine, spiralPaint);\n        //Toast.makeText(getContext(), count + \" \", Toast.LENGTH_SHORT).show();\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/edu/byuh/cis/templevis/TempleView.java	(revision 318ff6bf7feebd81ccec6dd52413fc6dfcaff75c)
+++ app/src/main/java/edu/byuh/cis/templevis/TempleView.java	(date 1619788897000)
@@ -839,7 +839,6 @@
 
             ResourceCache resourceCache = new ResourceCache(getContext(), temp);
 
-
             ImageCache.init(getResources(), temp, screenHeight);
             allLargeImageIds = ImageCache.getAllImageIds();
             allTempleInfoFileIds = ImageCache.getAllTempleInfoFileIds();
